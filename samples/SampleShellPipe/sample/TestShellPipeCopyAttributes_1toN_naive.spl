// Copyright (C) 2016  International Business Machines Corporation
// All Rights Reserved



// manual test:
// cat ../data/ozymandias.txt|countCharacters.pl - ----- 1>stdout.log 2>stderr.log




namespace sample;

use com.ibm.streamsx.shell::*;

composite TestShellPipeCopyAttributes_1toN_naive {

    param
    expression<rstring> $inputFile: dataDirectory() + "/ozymandias.txt";
    expression<rstring> $shellCommand: "./etc/wordCounter_withoutAutoflush.pl";
    expression<rstring> $tokenDelimiter: "-";
    expression<rstring> $lineDelimiter: "-----";

    type 

    InputType =
        float64 inputTimestamp,
        int64   inputLineNumber,
        rstring inputLine;

    OutputType =
        float64 inputTimestamp,
        int64   inputLineNumber,
        rstring inputLine,
        int64   outputWordNumber,
        int64   outputWordLength,
        rstring outputWord;
    

    graph


    // create a stream of tuples containing text lines for the ShellPipe operators below to consume
    stream<InputType> InputStream as Out = FileSource() {
    param
        file: $inputFile;
        format: line;
   output Out:
        inputTimestamp = getTimestampInSecs(),
        inputLineNumber = TupleNumber(); }
    () as DebugInputStream = FileSink(InputStream) { param file: "debug.TestShellPipeCopyAttributes_1toN_naive.InputStream.out"; format: txt; hasDelayField: true; flush: 1u; writePunctuations: true; }


    // execute a Perl script that copies lines from STDIN to STDOUT, and implicitly copy input attributes from most recently received input tuple
    ( stream<InputType, tuple<rstring stdoutLine>> STDOUTStream ;
      stream<rstring stderrLine> STDERRStream ) = ShellPipe(InputStream) {
    param
        command: $shellCommand + " " + $tokenDelimiter + " " + $lineDelimiter;
        stdinAttribute: inputLine;
        stdoutAttribute: "stdoutLine";
        stderrAttribute: "stderrLine"; }
    () as DebugSTDOUTStream = FileSink(STDOUTStream) { param file: "debug.TestShellPipeCopyAttributes_1toN_naive.STDOUTStream.out"; format: txt; hasDelayField: true; flush: 1u; writePunctuations: true; }
    () as DebugSTDERRStream = FileSink(STDERRStream) { param file: "debug.TestShellPipeCopyAttributes_1toN_naive.STDERRStream.out"; format: txt; hasDelayField: true; flush: 1u; writePunctuations: true; }
        

    // parse the lines written to STDOUT by the command, and copy input attributes with matching name and type from most recently received input tuple, which is probably not the corresponding tuple
    stream<OutputType> OutputStream = Custom(STDOUTStream) {
    logic 
    state: { mutable OutputType outputTuple; }
    onTuple STDOUTStream: {
        if (stdoutLine==$lineDelimiter) return;
        list<rstring> tokens = tokenize(stdoutLine, $tokenDelimiter, true);
        if (size(tokens)!=3) return;
        assignFrom(outputTuple, STDOUTStream); // .......... copy input attributes with matching name and type from most recently received input tuple
        outputTuple.outputWordNumber = (int64)tokens[0];
        outputTuple.outputWordLength = (int64)tokens[1];
        outputTuple.outputWord = tokens[2];
        submit(outputTuple, OutputStream);
    } }
    () as DebugOutputStream = FileSink(OutputStream) { param file: "debug.TestShellPipeCopyAttributes_1toN_naive.OutputStream.out"; format: txt; hasDelayField: true; flush: 1u; writePunctuations: true; }


    // log STDERR lines to Streams application trace
    () as LogSTDERRStream = Custom(STDERRStream) {
    logic onTuple STDERRStream: {
          appTrc(Trace.info, "STDERR from command '" + $shellCommand + "': " + stderrLine); } }

}

